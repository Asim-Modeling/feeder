/*
 * Copyright (C) 2002-2006 Intel Corporation
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 * 
 */
 
/**
 * @file mingo.h
 * @author Michael Adler
 * @date March, 2002
 *
 * Feeder interface called by instrumented programs to generate memory
 * traces.
 *
 * This interface is C, not C++.  It belongs to code that is bound into
 * an instrumented program, not the ASIM image.  C programs would not
 * appreciate the introduction of a new C++ module!
 * 
 */

#ifndef _MINGO_
#define _MINGO_

#include "asim/syntax.h"
#include "asim/restricted/mingo_reg.h"

//
// Figure out maximum size of host's int.
//
#if defined(__i386__)
typedef UINT32 HOST_UINT;
#elif defined(__ia64__)
typedef UINT64 HOST_UINT;
#else
#error Unknown host type (only i386 and ia64 supported)
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef union
{
    UINT64 w;
    struct 
    {
        UINT64 inst_count: 16;
        UINT64 access_size: 4; //  2^access_size = bytes
        UINT64 load_lock: 1;
        UINT64 register_target: 9;
        UINT64 cisc: 1;
        UINT64 stack_pntr_relative: 1;

        UINT64 hint:2;
        UINT64 ipf_load_type:4;
        UINT64 unused:26;

    } mem_read;
    struct 
    {
        UINT64 inst_count: 16;
        UINT64 access_size: 4; //  2^access_size = bytes
        UINT64 load_lock: 1;
        UINT64 unused: 9;
        UINT64 unused2: 1;
        UINT64 stack_pntr_relative: 1;

        UINT64 hint:2;
        UINT64 release:1;
        UINT64 spill:1;
        UINT64 unused3:28;

    } mem_write;
    struct 
    {
        UINT64 inst_count: 16;
        UINT64 access_size: 4; //  2^access_size = bytes
        UINT64 compare: 1;
        UINT64 register_target: 9;
        UINT64 release: 1;
        UINT64 acquire: 1;

        UINT64 unused:32;
    } mem_exchange;
    struct
    {
        UINT64 inst_count    :16;
        UINT64 mem_fence_enum: 3;
        UINT64 unused        :13;
        UINT64 unused2:32;
    } mem_fence;
    struct
    {
        UINT64 inst_count    :16;
        UINT64 unused: 5;
        UINT64 source_register: 9;
        UINT64 unused2: 2;
        UINT64 unused3:32;
    } dependent_read;
    struct
    {
        UINT64 inst_count    :16;
        UINT64 xfer_enum     :3; // MINGO_CONTROL_TRANSFER
        UINT64 indirect:1;
        UINT64 unused:1;
        UINT64 branch_target_register:9;
        UINT64 conditional:1;
        UINT64 taken:1;
        UINT64 unused2:32;
    } branch;
    struct
    {
        UINT64 inst_count:16;
        UINT64 sys_enun:3; // MINGO_SYSCALL
        UINT64 unused:13;
        UINT64 unused2:32;
    } syscall;
} MINGO_INFO;


/*
 * MINGO_NCPUs --
 *
 *  Returns the number of CPUs in the simulated context.
 */

extern int
MINGO_NCPUs(
    void);


/*
 * MINGO_Disable_Events --
 *
 *  Disable collection of events.  This is especially useful when handling
 *  signals if the I/O generated by Mingo's connection to ASIM would
 *  interfere with the signal handler.  It may also be used in startup
 *  code.
 *
 *  <<<< DO NOT ALLOW NEW THREADS TO BE CREATED WHILE MINGO EVENTS ARE
 *       DISABLED. >>>>
 */

extern void
MINGO_Disable_Events(
    void);

/*
 * MINGO_Resume_Events --
 *
 *  Enable event recording turned off by MINGO_Disable_Events.
 */

extern void
MINGO_Resume_Events(
    void);

/*
 * MINGO_Trigger --
 *
 *  Called when a trigger point is reached to start data collection.
 *  This allows the source code of the program being studied to be modified
 *  slightly to indicate interesting data collection points.  Mingo
 *  may then be set up to begin collecting events when one trigger is
 *  reached and stop collecting when another trigger is reached.
 *
 *  Non-zero trigger causes the event disable counter to be decremented.
 *  A zero trigger increments the disable counter, turning off events.
 *
 *  Passing -1 turns off events and sends an EOF message to Asim.
 */

extern void
MINGO_Trigger(
    INT32 trigger_id);

/*
 * MINGO_Thread_Start / MINGO_Thread_End --
 *
 *  Called by the instrumented program at the beginning / end of a thread.
 *
 *  +++ These calls must be made from within the new thread! +++
 */

extern void
MINGO_Thread_Start(
    void);

extern void
MINGO_Thread_End(
    void);

/*
 * MINGO_Thread_Priority --
 *
 *  "nice" value of thread.  Default value assumed if never called.
 */

extern void
MINGO_Thread_Priority(
    INT32   priority);


/*
 * MINGO_Thread_Preferred_CPU --
 *
 *  Thread may request a preferred CPU ID.  0 means no preference.  Must be no
 *  greater than the value returned by MINGO_NCPUs().
 */

extern void
MINGO_Thread_Preferred_CPU(
    UINT32  cpu_id);


/*
 * Many of the functions that follow use bit fields to compress many fields
 * into single UINT32.  The goal is to minimize the code growth of instrumented
 * programs.
 *
 * A few notes on the use of bit fields:
 *
 *  - All values compressed in bit fields may be compile-time constants.
 *    In no case may the instrumented program need run-time code to
 *    insert data in a bit field.
 *
 *  - Bit fields are declared as UINT32 with semantics described in comments
 *    above the code.  C itself does not define the order in which bit fields
 *    are stored within an int.  (It requires only that bit fields not span
 *    ints.)  Using comments instead of C constructs makes the layout
 *    unambiguous for assembly programmers and architecture/compiler neutral.
 */


/*
 * MINGO_Memory_Read --
 *
 *  Call this BEFORE executing a load.
 *
 *  The info field holds the following:
 *
 *  3 3 2               2 2 1     1 1
 *  1 0 9               1 0 9     6 5                             0
 * ----------------------------------------------------------------|
 * |S|C|     Register    |L| Access|      Executed Instruction     |
 * | | |      Target     | |  Size |             Count             |
 * ----------------------------------------------------------------|
 *
 * IPF only (IA32 passes only 32 bits):
 *
 *  6                                                 3 3     3 3 3
 *  3                                                 8 7     4 3 2
 * ----------------------------------------------------------------|
 * |                         U                         |  IPF  |Hnt|
 * |                                                   | Ldtype|   |
 * ----------------------------------------------------------------|
 *
 *  Executed Instruction Count --
 *      Number of instructions executed since previous call to any
 *      of the MINGO trace generation functions.  The performance
 *      model will use this to estimate timing.
 *
 *  Access Size --
 *      Load data size = 2 ^ Access Size bytes.
 *
 *  L --
 *      Load lock?  1 iff load is attempting to acquire a lock.
 *
 *  Register Target --
 *      Register names are defined in mingo_reg.h.
 *
 *  C --
 *      CISC access.  Load data is consumed by the same instruction.
 *      This bit is provided to simplify instrumentation.  It is
 *      equivalent to calling MINGO_Memory_Read() with C false followed
 *      immediatly by MINGO_Dependent_Read() before the CISC instruction.
 *
 *  S --
 *      1 iff SP (stack pointer) relative reference.
 *
 *  U --
 *      Unused.  Must be 0.
 *
 *  <<<< IPF only: >>>>
 *
 *  Hnt --
 *      Load hint completer.  Binary values:
 *          00 -- none
 *          01 -- nt1
 *          10 --
 *          11 -- nta
 *
 *  IPF ldtype --
 *      Load type.  High 4 bits of x6 extension encoding.  The size of
 *      the load (from the low two bits of x6) are stored in "Access
 *      Size" above.  Binary values are:
 *          0000 -- (normal)
 *          0001 -- s
 *          0010 -- a
 *          0011 -- sa
 *          0100 -- bias
 *          0101 -- acq
 *          0110 -- fill
 *          1000 -- c.clr
 *          1001 -- c.nc
 *          1010 -- c.clr.acq
 */

extern void
MINGO_Memory_Read(
    HOST_UINT IP,                   // IP of load
    HOST_UINT VA,                   // Virtual address loaded
    HOST_UINT info);                // Bit fields, see comment above


/*
 * MINGO_Memory_Write --
 *
 *  Call this BEFORE executing a store.
 *
 *  The low 32 bits of the info field are the same as MINGO_Memory_Read
 *  except the Register Target and CISC fields are unused.
 *
 *  On IPF only, the high 32 bits are:
 *
 *  6                                                     3 3 3 3 3
 *  3                                                     6 5 4 3 2
 * ----------------------------------------------------------------|
 * |                         U                             |S|R|Hnt|
 * |                                                       | | |   |
 * ----------------------------------------------------------------|
 *
 *  Hnt --
 *      Store hint completer.  Binary values:
 *          00 -- none
 *          01 --
 *          10 --
 *          11 -- nta
 *
 *  R --
 *      Store type is release.
 *
 *  S --
 *      Store type is spill.
 */

extern void
MINGO_Memory_Write(
    HOST_UINT IP,
    HOST_UINT VA,
    HOST_UINT info);

/*
 * MINGO_Memory_Exchange --
 *
 *  Call this BEFORE executing an XCHG or CMPXCHG.
 *
 *  The info field holds the following:
 *
 *  3 3 2               2 2 1     1 1
 *  1 0 9               1 0 9     6 5                             0
 * ----------------------------------------------------------------|
 * |A|R|     Register    |C| Access|      Executed Instruction     |
 * | | |      Target     | |  Size |             Count             |
 * ----------------------------------------------------------------|
 *
 *  Executed Instruction Count --
 *      See MINGO_Memory_Read().
 *
 *  Access Size --
 *      Load data size = 2 ^ Access Size bytes.
 *
 *  C --
 *      Compare and exchange (1) or simple exchange (0).  The compared
 *      value field has meaning only if this bit is set.  Two versions
 *      of this call are availabe.  One has a 32 bit compared_value and
 *      the other with a 64 bit argument.  It is permissible to call
 *      MINGO_Memory_Exchange64() with any access size.  The 32 bit
 *      version is provided as a convenience to minimize argument
 *      sizes on x86.
 *
 *  Register Target --
 *      Register names are defined in mingo_reg.h.
 *
 *  A/R --
 *      Itanium release and acquire semantics.  These bits appear
 *      independently in order to permit setting both.  x86 memory
 *      semantics are closest to both being set.
 */

extern void
MINGO_Memory_Exchange(
    HOST_UINT IP,
    HOST_UINT VA,
    HOST_UINT info,
    UINT32    compared_value);

extern void
MINGO_Memory_Exchange64(
    HOST_UINT IP,
    HOST_UINT VA,
    HOST_UINT info,
    UINT64    compared_value);


/*
 * MINGO_Memory_Fence --
 *
 *  Call this BEFORE executing a memory fence.
 *
 *  The info field holds the following:
 *
 *  3                       1 1   1 1
 *  1                       9 8   6 5                             0
 * ----------------------------------------------------------------|
 * |            U            |  MF |      Executed Instruction     |
 * |                         | enum|             Count             |
 * ----------------------------------------------------------------|
 *
 *  Executed Instruction Count --
 *      See MINGO_Memory_Read().
 *
 *  MF enum --
 *      Type of memory fence (MINGO_MEMORY_FENCE.)
 *
 *  U -- Unused.  Must be 0.
 */

typedef enum
{
    MINGO_FENCE_ORDERING,
    MINGO_FENCE_ACCEPTANCE
}
MINGO_MEMORY_FENCE;

extern void
MINGO_Memory_Fence(
    HOST_UINT IP,
    HOST_UINT info);


/*
 * MINGO_Dependent_Read --
 *
 *  Call this BEFORE executing an instruction that consumes data reported
 *  by MINGO_Memory_Read().
 *
 *  The info field holds the following:
 *
 *  3 3 2               2 2       1 1
 *  1 0 9               1 0       6 5                             0
 * ----------------------------------------------------------------|
 * | U |      Source     |    U    |      Executed Instruction     |
 * |   |     Register    |         |             Count             |
 * ----------------------------------------------------------------|
 *
 *  Executed Instruction Count --
 *      See MINGO_Memory_Read().
 *
 *  Source Register --
 *      Register written by previous load and consumed here.
 *
 *  U -- Unused.  Must be 0.
 */

extern void
MINGO_Dependent_Read(
    HOST_UINT IP,
    HOST_UINT info);


/*
 * MINGO_Branch --
 *
 *  Call this BEFORE executing a branch or other control transfer instruction.
 *
 *  The info field holds the following:
 *
 *  3 3 2               2 2 1 1   1 1
 *  1 0 9               1 0 9 8   6 5                             0
 * ----------------------------------------------------------------|
 * |T|C|  Branch Target  |U|I| XFER|      Executed Instruction     |
 * | | |     Register    | | | enum|             Count             |
 * ----------------------------------------------------------------|
 *
 *  Executed Instruction Count --
 *      See MINGO_Memory_Read().
 *
 *  XFER enum --
 *      Branch type.  One of MINGO_CONTROL_TRANSFER.
 *
 *  I --
 *      Indirection flag.  0 if IP relative, 1 if indirect through register.
 *
 *  Branch Target Register --
 *      Register number holding branch target.  May be none if IP relative.
 *
 *  Conditional --
 *      Conditional branch?  0 if no, 1 if yes.
 *
 *  Taken --
 *      Taken branch?  0 if no, 1 if yes.
 *
 *  U -- Unused.  Must be 0.
 */

typedef enum
{
    MINGO_XFER_BRANCH,
    MINGO_XFER_CALL,
    MINGO_XFER_RETURN
}
MINGO_CONTROL_TRANSFER;

extern void
MINGO_Branch(
    HOST_UINT IP,
    HOST_UINT target_IP,
    HOST_UINT info);


/*
 * MINGO_Note_Executed_Instrs --
 *
 *  Provided as a convenience to the instrumenter as another way of passing
 *  the current IP and dynamic instruction count.
 */

extern void
MINGO_Note_Executed_Instrs(
    HOST_UINT IP,
    UINT32    instr_count);


/*
 * MINGO_Syscall --
 *
 *  Call this BEFORE jumping to the kernel or to any uninstrumented region.
 *
 *  The info field holds the following:
 *
 *  3                       1 1   1 1
 *  1                       9 8   6 5                             0
 * ----------------------------------------------------------------|
 * |            U            | SYS |      Executed Instruction     |
 * |                         | enum|             Count             |
 * ----------------------------------------------------------------|
 *
 *  Executed Instruction Count --
 *      See MINGO_Memory_Read().
 *
 *  SYS enum --
 *      Operation to be performed (one of MINGO_SYSCALL).  The performance
 *      simulator may use this to estimate the work done in the
 *      uninstrumented region.
 *
 *      Use MINGO_SYSCALL_FAST if you expect the call to be quick and not
 *      to cause the thread to lose its scheduling slot.  Use
 *      MINGO_SYSCALL_SLOW for unknown behavior or calls expected to
 *      lose their scheduling slots.
 *
 *  U -- Unused.  Must be 0.
 */

typedef enum
{
    MINGO_SYSCALL_SLOW,
    MINGO_SYSCALL_FAST,
    MINGO_SYSCALL_MUTEX,
    MINGO_SYSCALL_IO
}
MINGO_SYSCALL;

extern void
MINGO_Syscall(
    HOST_UINT IP,
    HOST_UINT info);


/*
 * MINGO_Timed_Wait --
 *
 *  Request that performance model block the calling thread for the simulated
 *  number of nanoseconds.  Use this in a spin-lock to force a thread to sleep
 *  in simulator time instead of wall time.
 */

extern void
MINGO_Timed_Wait(
    UINT64 nsWait);


#ifdef __cplusplus
}
#endif

#endif // _MINGO_
