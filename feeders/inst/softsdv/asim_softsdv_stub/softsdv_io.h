/**************************************************************************
 * Copyright (C) 2003-2006 Intel Corporation
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 * 
 **************************************************************************/

/**
 * @file
 * @author Michael Adler
 * @brief SoftSDV shared memory I/O code for data transfer with SoftSDV
 */

#ifndef _SOFTSDV_IO_H
#define _SOFTSDV_IO_H

#include <sys/types.h>
#include <unistd.h>
#include <time.h>
#include <stdio.h>

//
// Asim includes
//
#define ASIM_MESG_H
#include "asim/dynamic_array.h"
#include "asim/atomic.h"
#include "asim/provides/softsdv_isa_data.h"


//-------------------------------------------------------------------------
//
// Structures here must have the same layout on both the SoftSDV and Asim
// sides.  They may be compiled in different modes (32 vs 64 bit).  Force
// the structure layout to be the same in each.
//
//-------------------------------------------------------------------------
#pragma pack(push,4)


//
// A few forward declarations...
//

typedef class SOFTSDV_IO_ASIM_SIDE_CLASS *SOFTSDV_IO_ASIM_SIDE;

typedef class SOFTSDV_IO_SOFTSDV_SIDE_CLASS *SOFTSDV_IO_SOFTSDV_SIDE;

typedef class SOFTSDV_IO_SPIN_CONTROL_CLASS *SOFTSDV_IO_SPIN_CONTROL;

typedef class ASIM_SOFTSDV_REQUEST_CLASS *ASIM_SOFTSDV_REQUEST;

typedef class ASIM_SOFTSDV_IO_LIST_CLASS *ASIM_SOFTSDV_IO_LIST;

typedef class SOFTSDV_IO_ASIM_SIDE_MEMORY_CLASS *SOFTSDV_IO_ASIM_SIDE_MEMORY;

typedef class SOFTSDV_IO_SOFTSDV_SIDE_MEMORY_CLASS *SOFTSDV_IO_SOFTSDV_SIDE_MEMORY;


//-------------------------------------------------------------------------
//
// Requests are generated by Asim and consumed by SoftSDV.  There are
// a number of request classes.  They are described below.
//
//-------------------------------------------------------------------------

enum ASIM_SOFTSDV_REQUEST_TYPES
{
    ASIM_REQUEST_NONE,
    ASIM_REQUEST_INIT,              // Start initialization phase
    ASIM_REQUEST_INIT_DONE,         // End       "            "
    ASIM_REQUEST_WARMUP,            // Pass information from Asim about
                                    //  warm-up data needed by the model.
    ASIM_REQUEST_REG_MONITOR,       // Passed only during initialization.
                                    //  requests SoftSDV send Asim updates
                                    //  to the register value on unexpected
                                    //  flow (e.g. interrupt).
    ASIM_REQUEST_FETCH              // Fetch some instructions
};

enum ASIM_SOFTSDV_WARMUP_METHOD
{
    ASIM_SDV_WARMUP_OFF,
    ASIM_SDV_WARMUP_ON
};

class ASIM_SOFTSDV_REQUEST_CLASS
{
  public:
    enum constants
    {
        MAX_SDV_BUFFERED_REQUESTS = 32
    };

    //
    // There are many constructors to deal with the possible message
    // types...
    //

    // NONE...
    ASIM_SOFTSDV_REQUEST_CLASS();

    // Requests with no arguments...
    ASIM_SOFTSDV_REQUEST_CLASS(ASIM_SOFTSDV_REQUEST_TYPES request);

    // WARMUP...
    ASIM_SOFTSDV_REQUEST_CLASS(
        ASIM_SOFTSDV_REQUEST_TYPES request,
        ASIM_SOFTSDV_WARMUP_METHOD wMethod);

    // REG_MONITOR...
    ASIM_SOFTSDV_REQUEST_CLASS(
        ASIM_SOFTSDV_REQUEST_TYPES request,
        const char *regName,
        UINT32 regUid,
        UINT32 regSize);

    // FETCH...
    ASIM_SOFTSDV_REQUEST_CLASS(
        ASIM_SOFTSDV_REQUEST_TYPES request,
        UINT32 cpuNum,
        UINT32 nInstrs);

    ~ASIM_SOFTSDV_REQUEST_CLASS() {};

    ASIM_SOFTSDV_REQUEST_TYPES Request(void) const { return request; };

    // WARMUP arguments
    ASIM_SOFTSDV_WARMUP_METHOD WarmUpMethod(void) const;

    // FETCH arguments
    UINT32 CpuNum(void) const;
    UINT32 NInstrs(void) const;

    // REG_MONITOR requests
    UINT32 RegNum(void) const;
    UINT32 RegSize(void) const;
    const char *RegName(void) const;

    void Reset(void)
    {
        request = ASIM_REQUEST_NONE;
    };

    //
    // Define a smart assignment operator to avoid copying unused fields
    //
    ASIM_SOFTSDV_REQUEST_CLASS& operator=(const ASIM_SOFTSDV_REQUEST_CLASS& rhs);

  private:
    ASIM_SOFTSDV_REQUEST_TYPES request;

    union
    {
        struct
        {
            UINT32 cpuNum;
            UINT32 nInstrs;
        } fetch;

        struct
        {
            UINT32 regNum;
            UINT32 regSize;
            char name[36];
        } regMonitor;

        struct
        {
            ASIM_SOFTSDV_WARMUP_METHOD method;
        } warmup;
    };
};


//
// WARMUP arguments
//
inline ASIM_SOFTSDV_WARMUP_METHOD
ASIM_SOFTSDV_REQUEST_CLASS::WarmUpMethod(void) const
{
    ASSERTX(request == ASIM_REQUEST_WARMUP);
    return warmup.method;
};


//
// CpuNum for FETCH requests
//
inline UINT32
ASIM_SOFTSDV_REQUEST_CLASS::CpuNum(void) const
{
//    ASSERTX(request == ASIM_REQUEST_FETCH);
    return fetch.cpuNum;
};

//
// NInstrs for FETCH requests
//
inline UINT32
ASIM_SOFTSDV_REQUEST_CLASS::NInstrs(void) const
{
    ASSERT(request == ASIM_REQUEST_FETCH, "Request isn't FETCH");
    return fetch.nInstrs;
};


//
// RegNum for REG_MONITOR requests
//
inline UINT32
ASIM_SOFTSDV_REQUEST_CLASS::RegNum(void) const
{
    return regMonitor.regNum;
};

//
// RegSize for REG_MONITOR requests
//
inline UINT32
ASIM_SOFTSDV_REQUEST_CLASS::RegSize(void) const
{
    return regMonitor.regSize;
};

//
// RegName for REG_MONITOR requests
//
inline const char*
ASIM_SOFTSDV_REQUEST_CLASS::RegName(void) const
{
    ASSERT(request == ASIM_REQUEST_REG_MONITOR, "Request isn't REG_MONITOR");
    return regMonitor.name;
};


// Default constructor
inline
ASIM_SOFTSDV_REQUEST_CLASS::ASIM_SOFTSDV_REQUEST_CLASS()
    : request(ASIM_REQUEST_NONE)
{};


// Requests with no arguments
inline
ASIM_SOFTSDV_REQUEST_CLASS::ASIM_SOFTSDV_REQUEST_CLASS(
    ASIM_SOFTSDV_REQUEST_TYPES request)
    : request(request)
{
    ASSERTX((request == ASIM_REQUEST_INIT) ||
            (request == ASIM_REQUEST_INIT_DONE));
};


// Tell SoftSDV whether Asim wants warm-up data
inline
ASIM_SOFTSDV_REQUEST_CLASS::ASIM_SOFTSDV_REQUEST_CLASS(
    ASIM_SOFTSDV_REQUEST_TYPES request,
    ASIM_SOFTSDV_WARMUP_METHOD wMethod)
    : request(request)
{
    ASSERTX(request == ASIM_REQUEST_WARMUP);

    warmup.method = wMethod;
};


// Monitor a register
inline
ASIM_SOFTSDV_REQUEST_CLASS::ASIM_SOFTSDV_REQUEST_CLASS(
    ASIM_SOFTSDV_REQUEST_TYPES request,
    const char *regName,
    UINT32 regNum,
    UINT32 regSize)
    : request(request)
{
    ASSERTX(request == ASIM_REQUEST_REG_MONITOR);
    ASSERT(strlen(regName) < sizeof(regMonitor.name),
           "Register name doesn't fit in ASIM_SOFTSDV_REQUEST.  Make name[] bigger.");

    regMonitor.regNum = regNum;
    regMonitor.regSize = regSize;
    strcpy(regMonitor.name, regName);
};


// Fetch instructions
inline
ASIM_SOFTSDV_REQUEST_CLASS::ASIM_SOFTSDV_REQUEST_CLASS(
    ASIM_SOFTSDV_REQUEST_TYPES request,
    UINT32 cpuNum,
    UINT32 nInstrs)
    : request(request)
{
    ASSERTX(request == ASIM_REQUEST_FETCH);

    fetch.cpuNum = cpuNum;
    fetch.nInstrs = nInstrs;
};


// Assignment operator
inline
ASIM_SOFTSDV_REQUEST_CLASS&
ASIM_SOFTSDV_REQUEST_CLASS::operator=(
    const ASIM_SOFTSDV_REQUEST_CLASS& rhs)
{
    request = rhs.request;

    switch (request)
    {
      case ASIM_REQUEST_NONE:
      case ASIM_REQUEST_INIT:
      case ASIM_REQUEST_INIT_DONE:
        break;

      case ASIM_REQUEST_WARMUP:
        warmup = rhs.warmup;
        break;

      case ASIM_REQUEST_FETCH:
        fetch = rhs.fetch;
        break;

      case ASIM_REQUEST_REG_MONITOR:
        regMonitor = rhs.regMonitor;
        break;

      default:
        ASSERT(false, "Unhandled request type");
        break;
    }

    return *this;
}


//-------------------------------------------------------------------------
//
// Class common to both Asim and SoftSDV sides for managing lists of
// active communication classes.  These are mainly used for making sure
// shutdown is orderly and all processes are stopped.
//
//-------------------------------------------------------------------------


class ASIM_SOFTSDV_IO_LIST_CLASS
{
  public:
    enum WHICH_SIDE
    {
        NEITHER,
        ASIM_SIDE,
        SOFTSDV_SIDE
    };

  public:
    //
    // Constructors can be neutral or specific either to the Asim or
    // SoftSDV side.  Once a single constructor has been called that
    // is side-specific, all future contructors called in the process
    // must either be neutral or specific to the same side.
    //
    ASIM_SOFTSDV_IO_LIST_CLASS(void);
    ASIM_SOFTSDV_IO_LIST_CLASS(SOFTSDV_IO_ASIM_SIDE asimIo);
    ASIM_SOFTSDV_IO_LIST_CLASS(SOFTSDV_IO_SOFTSDV_SIDE softsdvIo);

    ~ASIM_SOFTSDV_IO_LIST_CLASS();

    //
    // About to exit.  Make sure Asim and all SoftSDV processes know.
    //
    static void Exiting(void);

  private:
    void SetSide(WHICH_SIDE newSide);

    static WHICH_SIDE side;
    static ASIM_SOFTSDV_IO_LIST head;

    ASIM_SOFTSDV_IO_LIST next;
    SOFTSDV_IO_ASIM_SIDE asimIo;
    SOFTSDV_IO_SOFTSDV_SIDE softsdvIo;
};


//-------------------------------------------------------------------------
//
// Public data for ring buffers.  Templates allow for creating
// instances of varying size rings and payloads.
//
// There are separate reader and writer side components here so that
// the two halves of a ring buffer can be stored in separate shared
// memory buffers.  The two halves of the buffer can then be tagged
// read-only in one process.
//
//-------------------------------------------------------------------------


//
// Definition of global storage of the control structure for the
// reader side of a ring.
//
template <int softsdv_io_ring_entries>
class SOFTSDV_IO_RING_READER_DATA_CLASS
{
  public:
    SOFTSDV_IO_RING_READER_DATA_CLASS(void) :
        currentSlot(0)
    {};

    ~SOFTSDV_IO_RING_READER_DATA_CLASS() {};

    UINT32 Slot(void) volatile
    {
        MemBarrier();
        return currentSlot;
    };

    void SetSlot(UINT32 slot) volatile
    {
        MemBarrier();
        currentSlot = slot;
        MemBarrier();
    };

    //
    // Increment a slot index and return the new value.
    //
    UINT32 Increment(void) volatile
    {
        UINT32 nextSlot = Slot();
        nextSlot += 1;
        nextSlot &= (softsdv_io_ring_entries - 1);
        SetSlot(nextSlot);
        return nextSlot;
    };

  private:
    UINT32 currentSlot;
};


//
// The writer side of ring uses the same control structures as a reader but
// adds global storage for the payload.
//
template <int softsdv_io_ring_entries, class PAYLOAD_CLASS>
class SOFTSDV_IO_RING_WRITER_DATA_CLASS :
    public SOFTSDV_IO_RING_READER_DATA_CLASS<softsdv_io_ring_entries>
{
  public:
    SOFTSDV_IO_RING_WRITER_DATA_CLASS(void) :
        SOFTSDV_IO_RING_READER_DATA_CLASS<softsdv_io_ring_entries>()
    {};

    ~SOFTSDV_IO_RING_WRITER_DATA_CLASS() {};

    //
    // Pointer to the payload, given a slot in the ring
    // buffer.  Reader sides of rings may call this function too (assuming
    // they have a handle to the writer side).  The data structure doesn't
    // prevent readers from modifying the data here but we can rely on the
    // OS mapping the shared memory read-only on the reader side to prevent
    // updates.
    //
    PAYLOAD_CLASS *ObjPtr(UINT32 slot)
    {
        return &(payload[slot]);
    };

  private:
    PAYLOAD_CLASS payload[softsdv_io_ring_entries];
};


//-------------------------------------------------------------------------
//
// Spin control (process blocking waiting for data)
//
//-------------------------------------------------------------------------

class SOFTSDV_IO_SPIN_CONTROL_CLASS
{
  public:
    SOFTSDV_IO_SPIN_CONTROL_CLASS(
        ASIM_SOFTSDV_IO_LIST_CLASS::WHICH_SIDE side,
        SOFTSDV_IO_ASIM_SIDE_MEMORY asimMem,
        SOFTSDV_IO_SOFTSDV_SIDE_MEMORY softsdvMem,
        int syncPipeIn) :
        side(side),
        asimMem(asimMem),
        softsdvMem(softsdvMem),
        syncPipeIn(syncPipeIn)
    {
        ASSERTX(side != ASIM_SOFTSDV_IO_LIST_CLASS::NEITHER);
    };

    ~SOFTSDV_IO_SPIN_CONTROL_CLASS() {};

    //
    // Call blocked in a spin loop when no data is available.  It spins quickly
    // for a while then starts to slow down and yield to the OS.  Initialize
    // the timeTag value to 0 before the first call in a spin loop and let
    // Blocked() update it as needed.  The value is used internally and may
    // not actually reflect elapsed time.
    //
    // Returns true as long as it believes the remote process is active and
    // false if the remote process cleared its isActive flag.
    //
    bool Blocked(UINT32 trip, time_t *timeTag);

  private:
    const ASIM_SOFTSDV_IO_LIST_CLASS::WHICH_SIDE side;
    const SOFTSDV_IO_ASIM_SIDE_MEMORY asimMem;
    const SOFTSDV_IO_SOFTSDV_SIDE_MEMORY softsdvMem;
    int syncPipeIn;
};



//-------------------------------------------------------------------------
//
// These classes combine reader and writer ring classes from above into
// an integrated control structure for a ring buffer.  The class should
// be allocated in memory private to a process.
//
//-------------------------------------------------------------------------


//
// Reader side.  Requires handle to both reader and writer global data but
// updates only the reader side.
//
template <int softsdv_io_ring_entries, class PAYLOAD_CLASS>
class SOFTSDV_IO_RING_READER_CLASS
{
  public:
    SOFTSDV_IO_RING_READER_CLASS(
        SOFTSDV_IO_RING_READER_DATA_CLASS<softsdv_io_ring_entries> *reader,
        SOFTSDV_IO_RING_WRITER_DATA_CLASS<softsdv_io_ring_entries, PAYLOAD_CLASS> *writer,
        SOFTSDV_IO_SPIN_CONTROL spin) :
        reader(reader),
        writer(writer),
        spin(spin)
    {
        ASSERT((softsdv_io_ring_entries & (softsdv_io_ring_entries - 1)) == 0,
               "Number of entries in ring must be a power of 2!");
        ASSERTX(reader != NULL);

        ringEntryOpen = false;
    };

    
    ~SOFTSDV_IO_RING_READER_CLASS() {};

    //
    // Number of slots with data ready in the ring.
    //
    UINT32 NReadSlotsAvailable(void)
    {
        return ((writer->Slot() + softsdv_io_ring_entries) - reader->Slot()) &
               (softsdv_io_ring_entries - 1);
    };

    //
    // Blocks until data are available for this simulated CPU.
    //
    PAYLOAD_CLASS *OpenNext(void)
    {
        ASSERT(! ringEntryOpen, "Only one instruction can be open at a time");

        UINT32 trip = 0;
        time_t timeTag = 0;
        while (NReadSlotsAvailable() == 0)
        {
            trip += 1;
            if (! spin->Blocked(trip, &timeTag))
            {
                //
                // Remove process cleared its isActive flag.
                //
                return NULL;
            }
        }

        ringEntryOpen = true;
        return writer->ObjPtr(reader->Slot());
    };

    //
    // Close object opened with OpenNext().
    //
    void Close(const PAYLOAD_CLASS *obj)
    {
        ASSERTX(ringEntryOpen);

        reader->Increment();
        ringEntryOpen = false;
    };

  private:
    SOFTSDV_IO_RING_READER_DATA_CLASS<softsdv_io_ring_entries> * const reader;
    SOFTSDV_IO_RING_WRITER_DATA_CLASS<softsdv_io_ring_entries, PAYLOAD_CLASS> * const writer;

    SOFTSDV_IO_SPIN_CONTROL spin;

    bool ringEntryOpen;
};


//
// Writer side.  Requires handle to both reader and writer global data but
// updates only the writer side.
//
template <int softsdv_io_ring_entries, class PAYLOAD_CLASS>
class SOFTSDV_IO_RING_WRITER_CLASS
{
  public:
    //
    // Reader may be NULL if the consuming process doesn't exist.  (E.g.
    // debugging one side.)
    //
    SOFTSDV_IO_RING_WRITER_CLASS(
        SOFTSDV_IO_RING_WRITER_DATA_CLASS<softsdv_io_ring_entries, PAYLOAD_CLASS> *writer,
        SOFTSDV_IO_RING_READER_DATA_CLASS<softsdv_io_ring_entries> *reader,
        SOFTSDV_IO_SPIN_CONTROL spin) :
        writer(writer),
        reader(reader),
        spin(spin)
    {
        ASSERT((softsdv_io_ring_entries & (softsdv_io_ring_entries - 1)) == 0,
               "Number of entries in ring must be a power of 2!");
        ASSERTX(writer != NULL);

        ringEntryOpen = false;
    };

    //
    // Compute the number of empty slots in a ring.  This actually returns
    // one less than the true number of slots because we never want to write
    // to the last slot available.  Doing so would cause the next read pointer
    // and the next write pointer to be identical.  That case is reserved for
    // the queue being completely empty, not completely full.
    //
    UINT32 NWriteSlotsAvailable(void)
    {
        if (reader == NULL)
        {
            //
            // Nobody home on the other side.  (Probably running for
            // debugging without Asim.)
            //
            return softsdv_io_ring_entries;
        }

        return ((reader->Slot() + (softsdv_io_ring_entries - 1)) -
                writer->Slot()) &
               (softsdv_io_ring_entries - 1);
    };

    //
    // Blocks until write slot is available for this ring.
    //
    PAYLOAD_CLASS *OpenNext(void)
    {
        ASSERT(! ringEntryOpen, "Only one instruction can be open at a time");

        UINT32 trip = 0;
        time_t timeTag = 0;
        while (NWriteSlotsAvailable() == 0)
        {
            trip += 1;
            if (! spin->Blocked(trip, &timeTag))
            {
                //
                // Remove process cleared its isActive flag.
                //
                return NULL;
            }
        }

        ringEntryOpen = true;

        PAYLOAD_CLASS *obj = writer->ObjPtr(writer->Slot());
        obj->Reset();
        return obj;
    };

    //
    // Call this after the ring entry from OpenNext() has valid data.
    // This call will inform the reader side that the entry is valid.
    //
    void Close(const PAYLOAD_CLASS *obj)
    {
        ASSERT(ringEntryOpen && (obj == writer->ObjPtr(writer->Slot())),
               "Attempt to close an unopened instruction entry");

        UINT32 nextReadSlot = (reader == NULL) ? 0 : reader->Slot();
        UINT32 nextWriteSlot = writer->Increment();

        ASSERT((reader == NULL) || (nextWriteSlot != nextReadSlot),
               "Ring buffer overrun.");

        ringEntryOpen = false;
    };

  private:
    SOFTSDV_IO_RING_WRITER_DATA_CLASS<softsdv_io_ring_entries, PAYLOAD_CLASS> * const writer;
    SOFTSDV_IO_RING_READER_DATA_CLASS<softsdv_io_ring_entries> * const reader;

    SOFTSDV_IO_SPIN_CONTROL spin;

    bool ringEntryOpen;
};


//-------------------------------------------------------------------------
//
// Asim side of the I/O class to manage the shared memory buffer.  The
// class is visible on both sides of the interface.
//
//-------------------------------------------------------------------------

typedef SOFTSDV_IO_RING_READER_DATA_CLASS<N_SOFTSDV_INSTR_RING_ENTRIES>
    ASIM_SIDE_INSTR_RING_READER_CLASS;

//
// This class will hold the shared data written on the Asim side.
// The shared region is in a struct outside of the accessing class
// in order to simplify allocation of the shared memory buffer.
//
class SOFTSDV_IO_ASIM_SIDE_MEMORY_CLASS
{
  public:
    //
    // All backing storage is 0 when the class is constructed since it
    // is a shared memory buffer built by a parent class.
    //
    SOFTSDV_IO_ASIM_SIDE_MEMORY_CLASS(void) {};
    ~SOFTSDV_IO_ASIM_SIDE_MEMORY_CLASS() {};

    bool IsActive(void) volatile { MemBarrier(); return isActive; }
    void SetIsActive(void) { MemBarrier(); isActive = true; MemBarrier(); }
    void ClearIsActive(void) { MemBarrier(); isActive = false; MemBarrier(); }

    pid_t AsimPid(void) volatile { return asimPid; }
    void SetAsimPid(pid_t pid) { MemBarrier(); asimPid = pid; MemBarrier(); }

    pid_t SoftsdvPid(void) volatile { return softsdvPid; }
    void SetSoftsdvPid(pid_t pid) { MemBarrier(); softsdvPid = pid; MemBarrier(); }

    UINT32 NCpus(void) volatile { MemBarrier(); return nCpus; };
    void SetNCpus(UINT32 _nCpus)
    {
        MemBarrier();
        nCpus = _nCpus;
        MemBarrier();
    };

    bool OSMode(void) volatile { MemBarrier(); return osMode; };
    void SetOSMode(void) { MemBarrier(); osMode = true; MemBarrier(); };

    bool RecordRegisterValues(void) volatile { MemBarrier(); return recordRegisterValues; };
    void SetRecordRegisterValues(void) { MemBarrier(); recordRegisterValues = true; MemBarrier(); };

    bool RecordMemoryValues(void) volatile { MemBarrier(); return recordMemoryValues; };
    void SetRecordMemoryValues(void) { MemBarrier(); recordMemoryValues = true; MemBarrier(); };

    bool MonitorDMA(void) volatile { MemBarrier(); return monitorDMA; };
    void SetMonitorDMA(void) { MemBarrier(); monitorDMA = true; MemBarrier(); };

    //
    // Register values coming toward Asim
    //
    SOFTSDV_IO_RING_READER_DATA_CLASS<N_SOFTSDV_REG_RING_ENTRIES> regValueRing;

    //
    // Queue of fetch requests generated by Asim
    //
    SOFTSDV_IO_RING_WRITER_DATA_CLASS<
        ASIM_SOFTSDV_REQUEST_CLASS::MAX_SDV_BUFFERED_REQUESTS,
        ASIM_SOFTSDV_REQUEST_CLASS> asimRequestQueue;

  private:
    //
    // Is the Asim process still active?  Cleared on exit.
    //
    bool isActive;

    //
    // pid of asim process, so SoftSDV can check to see whether Asim is
    // still alive.
    //
    pid_t asimPid;

    //
    // Keep SoftSDV pid in the same place as asimPid.  The spin control code
    // might need it.
    //
    pid_t softsdvPid;

    //
    // Simulated number of CPUs according to SoftSDV.
    //
    UINT32 nCpus;

    //
    // Running in OS mode?
    //
    bool osMode;

    //
    // Does Asim want register and/or memory values?
    //
    bool recordRegisterValues;
    bool recordMemoryValues;

    //
    // Monitor DMA traffic in SoftSDV?
    //
    bool monitorDMA;
};


//-------------------------------------------------------------------------
//
// SoftSDV side of the I/O class to manage the shared memory buffer.  The
// class is visible on both sides of the interface.
//
//-------------------------------------------------------------------------

typedef SOFTSDV_IO_RING_WRITER_DATA_CLASS<
            N_SOFTSDV_INSTR_RING_ENTRIES,
            ASIM_SOFTSDV_INST_INFO_CLASS> SOFTSDV_SIDE_INSTR_RING_WRITER_CLASS;

//
// This class will hold the shared data written on the SoftSDV side.
// The shared region is in a struct outside of the accessing class
// in order to simplify allocation of the shared memory buffer.
//
class SOFTSDV_IO_SOFTSDV_SIDE_MEMORY_CLASS
{
  public:
    //
    // All backing storage is 0 when the class is constructed since it
    // is a shared memory buffer built by a parent class.
    //
    SOFTSDV_IO_SOFTSDV_SIDE_MEMORY_CLASS(void) {};
    ~SOFTSDV_IO_SOFTSDV_SIDE_MEMORY_CLASS() {};
    
    bool IsActive(void) volatile { MemBarrier(); return isActive; }
    void SetIsActive(void) { MemBarrier(); isActive = true; MemBarrier(); }
    void ClearIsActive(void) { MemBarrier(); isActive = false; MemBarrier(); }

    bool NormalExit(void) volatile { MemBarrier(); return normalExit; }
    void SetNormalExit(void) { MemBarrier(); normalExit = true; MemBarrier(); }
    void ClearNormalExit(void) { MemBarrier(); normalExit = false; MemBarrier(); }

    //
    // Register values coming from SoftSDV
    //
    SOFTSDV_IO_RING_WRITER_DATA_CLASS<
        N_SOFTSDV_REG_RING_ENTRIES,
        ASIM_SOFTSDV_REG_INFO_CLASS> regValueRing;

    //
    // Request queue coming from Asim
    //
    SOFTSDV_IO_RING_READER_DATA_CLASS<
        ASIM_SOFTSDV_REQUEST_CLASS::MAX_SDV_BUFFERED_REQUESTS> asimRequestQueue;

  private:
    //
    // Is SoftSDV still active?  Cleared on exit.
    //
    bool isActive;

    //
    // Normal exit.  Set when SoftSDV terminates at what it believes is the
    // end of the workload.
    //
    bool normalExit;
};


//-------------------------------------------------------------------------
//
// Asim side of the I/O.  Allocated only in the Asim process.  Builds the
// shared memory buffers for both sides and invokes SoftSDV.
//
//-------------------------------------------------------------------------

class SOFTSDV_IO_ASIM_SIDE_CLASS : private ASIM_SOFTSDV_IO_LIST_CLASS
{
  public:
    SOFTSDV_IO_ASIM_SIDE_CLASS(
        UINT32 argc,
        char **argv,
        char **envp,
        bool recordRegisterValues,
        bool recordMemoryValues,
        bool monitorDMATraffic
    );
    ~SOFTSDV_IO_ASIM_SIDE_CLASS();

    //
    // Called when Asim is exiting.
    //
    void Exiting(void);

    UINT32 NCpus(void) { return asimMem->NCpus(); };
    bool OSMode(void) { return asimMem->OSMode(); };
    bool RecordRegisterValues(void) { return asimMem->RecordRegisterValues(); };
    bool RecordMemoryValues(void) { return asimMem->RecordMemoryValues(); };
    bool MonitorDMA(void) { return asimMem->MonitorDMA(); };

    pid_t AsimPid(void) { return asimMem->AsimPid(); };
    pid_t SoftsdvPid(void) { return asimMem->SoftsdvPid(); };

    //
    // Instructions flowing from SoftSDV
    //
    SOFTSDV_IO_RING_READER_CLASS<
        N_SOFTSDV_INSTR_RING_ENTRIES,
        ASIM_SOFTSDV_INST_INFO_CLASS> &InstrRing(UINT32 cpu)
    {
        return *instrRing[cpu];
    };

    //
    // Register values from SoftSDV
    //
    SOFTSDV_IO_RING_READER_CLASS<
        N_SOFTSDV_REG_RING_ENTRIES,
        ASIM_SOFTSDV_REG_INFO_CLASS>
    &RegValues(void) { return *regValueRing; };

    //
    // Requests coming from Asim
    //
    SOFTSDV_IO_RING_WRITER_CLASS<
        ASIM_SOFTSDV_REQUEST_CLASS::MAX_SDV_BUFFERED_REQUESTS,
        ASIM_SOFTSDV_REQUEST_CLASS>
    &AsimRequestQueue(void) { return *asimRequestQueue; };

    int pipeIn;
    int pipeOut;

  private:
    //
    // Pointers and information about the shared memory buffers
    //
    SOFTSDV_IO_ASIM_SIDE_MEMORY asimMem;
    SOFTSDV_IO_SOFTSDV_SIDE_MEMORY softsdvMem;

    //
    // Instructions flowing from SoftSDV
    //
    typedef SOFTSDV_IO_RING_READER_CLASS<
        N_SOFTSDV_INSTR_RING_ENTRIES,
        ASIM_SOFTSDV_INST_INFO_CLASS>* IO_RING_READER;

    DYNAMIC_ARRAY_CLASS<IO_RING_READER> instrRing;

    //
    // Register values flowing from SoftSDV
    //
    SOFTSDV_IO_RING_READER_CLASS<
        N_SOFTSDV_REG_RING_ENTRIES,
        ASIM_SOFTSDV_REG_INFO_CLASS> *regValueRing;

    //
    // Requests coming from Asim
    //
    SOFTSDV_IO_RING_WRITER_CLASS<
        ASIM_SOFTSDV_REQUEST_CLASS::MAX_SDV_BUFFERED_REQUESTS,
        ASIM_SOFTSDV_REQUEST_CLASS> *asimRequestQueue;

    //
    // Allocate a 'size' byte shared memory buffer with specified protection
    // mask (see man mmap(2).).  Return address of buffer and also associated
    // file descriptor in fd.
    //
    void *AllocateSharedMemory(UINT32 size, int prot, int *fd);
};



//-------------------------------------------------------------------------
//
// SoftSDV side of the I/O.  Allocated only in the SoftSDV process.
// Opens the shared memory buffers created by Asim.
//
//-------------------------------------------------------------------------

class SOFTSDV_IO_SOFTSDV_SIDE_CLASS : private ASIM_SOFTSDV_IO_LIST_CLASS
{
  public:
    SOFTSDV_IO_SOFTSDV_SIDE_CLASS(void);
    ~SOFTSDV_IO_SOFTSDV_SIDE_CLASS();

    //
    // Called when SoftSDV is exiting.
    //
    void Exiting(bool normalExit = false);

    //
    // A convenient way of finding out whether SoftSDV is connected to Asim.
    // If the shared memory wasn't allocated return 0.  Otherwise return the
    // pid of the Asim parent process.
    //
    pid_t AsimPid(void) 
    {
        if (asimMem == NULL)
        {
            return 0;
        }
        else
        {
            return asimMem->AsimPid();
        }
    };

    bool AsimIsActive(void) { return (asimMem != NULL) && asimMem->IsActive(); };

    UINT32 NCpus(void) { return nCpus; };
    UINT32 NCpusAsim(void) { return asimMem->NCpus(); };
    void SetNCpus(UINT32 _nCpus) { nCpus = _nCpus; };

    bool OSMode(void) { return osMode; };
    bool OSModeAsim(void) { return asimMem->OSMode(); };
    void SetOSMode(void) { osMode = true; };

    bool RecordRegisterValues(void) { return recordRegisterValues; };
    void SetRecordRegisterValues(void) { recordRegisterValues = true; };

    bool RecordMemoryValues(void) { return recordMemoryValues; };
    void SetRecordMemoryValues(void) { recordMemoryValues = true; };

    bool MonitorDMA(void) { return monitorDMA; };
    bool MonitorDMAAsim(void) { return asimMem->MonitorDMA(); };
    void SetMonitorDMA(void) { monitorDMA = true; };

    //
    // Instructions flowing to Asim
    //
    SOFTSDV_IO_RING_WRITER_CLASS<
        N_SOFTSDV_INSTR_RING_ENTRIES,
        ASIM_SOFTSDV_INST_INFO_CLASS> &InstrRing(UINT32 cpu)
    {
        return *instrRing[cpu];
    };

    //
    // Register values flowing to Asim
    //
    SOFTSDV_IO_RING_WRITER_CLASS<
        N_SOFTSDV_REG_RING_ENTRIES,
        ASIM_SOFTSDV_REG_INFO_CLASS>
    &RegValues(void) { return *regValueRing; };

    //
    // Requests coming from Asim
    //
    SOFTSDV_IO_RING_READER_CLASS<
        ASIM_SOFTSDV_REQUEST_CLASS::MAX_SDV_BUFFERED_REQUESTS,
        ASIM_SOFTSDV_REQUEST_CLASS>
    &AsimRequestQueue(void) { return *asimRequestQueue; };

    //
    // Write one byte to the synchronization pipe
    //
    void SendSyncPacket(void)
    {
        if (pipeOut != -1)
        {
            char c;
            write(pipeOut, &c, 1);
        }
    };

  private:
    //
    // Pointers and information about the shared memory buffers
    //
    SOFTSDV_IO_SOFTSDV_SIDE_MEMORY softsdvMem;
    SOFTSDV_IO_ASIM_SIDE_MEMORY asimMem;

    //
    // Instructions flowing to Asim
    //
    typedef SOFTSDV_IO_RING_WRITER_CLASS<
        N_SOFTSDV_INSTR_RING_ENTRIES,
        ASIM_SOFTSDV_INST_INFO_CLASS> *IO_RING_WRITER;

    DYNAMIC_ARRAY_CLASS<IO_RING_WRITER> instrRing;

    //
    // Register values flowing to Asim
    //
    SOFTSDV_IO_RING_WRITER_CLASS<
        N_SOFTSDV_REG_RING_ENTRIES,
        ASIM_SOFTSDV_REG_INFO_CLASS> *regValueRing;

    //
    // Requests coming from Asim
    //
    SOFTSDV_IO_RING_READER_CLASS<
        ASIM_SOFTSDV_REQUEST_CLASS::MAX_SDV_BUFFERED_REQUESTS,
        ASIM_SOFTSDV_REQUEST_CLASS> *asimRequestQueue;

    //
    // Used for managing spin waits
    //
    SOFTSDV_IO_SPIN_CONTROL spin;

    //
    // Cross-process synchronization pipes.
    //
    int pipeIn;
    int pipeOut;

    //
    // Simulated number of CPUs according to SoftSDV.  This is replicated
    // here instead of just using the asimMem version for two reasons:
    // SoftSDV needs the number of CPUs before the connection to Asim
    // is established and the Asim stub in SoftSDV must be able to run
    // even when not connected to Asim.
    //
    // Startup code in cpuapi_interface verifies that nCpus here and the
    // value in asimMem match.
    //
    UINT32 nCpus;

    //
    // Running in OS mode?  This is duplicated in asimMem as well for
    // reasons similar to nCpus above.
    //
    bool osMode;

    //
    // Is Asim requesting register values?  This is also duplicated in
    // asimMem.  It is a located here for debugging reasons.  When
    // running without Asim it is useful to be able to set the value
    // with the debugger to turn on recording.
    //
    bool recordRegisterValues;
    bool recordMemoryValues;

    //
    // Monitor DMA traffic in SoftSDV?  Duplicated from asimMem.
    //
    bool monitorDMA;
};

#pragma pack(pop)

#endif // _SOFTSDV_IO_H
