: # -*-Perl-*-
eval 'exec perl -w "$0" ${1+"$@"}'
    if 0;

#
#  Copyright (C) 2005-2006 Intel Corporation
#  
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#  
#


#
# Author:  Michael Adler
#
# SoftSDV doesn't provide a map from the standard decoder's (Falcon's)
# register names to CPUAPI names for the registers.  Pass the decoder's
# header file that defines IA_Decoder_Operand_Name (e.g. decp69.h) as
# stdin to this script and it will write a C program on stdout with
# an array that maps from the deconder enumeration to CPUAPI strings.
#

use strict;

sub translate_reg($)
{
    my $r = shift;
    $r =~ s/IA_DECODER_//;

    # Ignore everything that doesn't begin with REG_
    if (!($r =~ /REG_/)) {
        return '0';
    }

    $r =~ s/REG_//;

  SWITCH:
    foreach ($r) {
        /^[ECSDFG]S$/        && do { $r = "${r}_SEL"; last; };

        /^TR$/               && do { $r = "${r}_SEL"; last; };

        /^FPCW/              && do { $r = "FCONTROL"; last; };
        /^FPSW/              && do { $r = "FSTATUS"; last; };
        /^FPTAG/             && do { $r = "FTAG"; last; };
        /^FPOPCODE/          && do { $r = "FOPCODE"; last; };
        /^FPIP_OFF/          && do { $r = "FINST_OFFSET"; last; };
        /^FPIP_SEL/          && do { $r = "FINST_SEL"; last; };
        /^FPDP_OFF/          && do { $r = "FDATA_OFFSET"; last; };
        /^FPDP_SEL/          && do { $r = "FDATA_SEL"; last; };

        # FP stack
        /^ST[0-7]$/          && do { $r =~ s/ST/FR/; last; };

        # MM registers are the same as FP stack
        /^MM[0-7]/           && do { $r =~ s/MM/FR/; last; };

        # No CPUAPI equivalent
        /^TR[0-7]$/          && do { $r = ''; last; };

        # Gambit ignores these registers when decoding
        /^TSSR/              && do { $r = ''; last; };
        /^LDTR/              && do { $r = ''; last; };
        /^[ECSDFG]SR_/       && do { $r = ''; last; };

        # Pseudo entries
        /^LAST$/             && do { $r = ''; last; };
    }

    if ($r eq '') {
        return '0';
    }

    return "CPUAPI_IA32_${r}";
}

my @regs = ();


##
## Loop through all enumerations in the file, looking for the
## IA_Decoder_Operand_Name enumeration.  We won't know we found it
## until the last line of the enumeration.
##

while (<STDIN>) {
    chomp($_);

    # Drop all spaces, comments, commas...
    my $s = $_;
    $s =~ s/ //g;
    $s =~ s/[,;\/].*//;

    if ($s eq "typedefenum") {
        # Start a new enum
        @regs = ();
    }
    elsif ($s =~ /^IA_DECODER/) {
        # Match an element in the enumeration

        # Check for assigned values.  A true parser that understands
        # values would fit nicely here, but isn't really worth the effort.
        if ($s =~ /=/) {
            if ($s eq 'IA_DECODER_NO_REG=0') {
                $s = 'IA_DECODER_NO_REG';
            }
            elsif ($s eq 'IA_DECODER_REG_CR8=IA_DECODER_REG_CR0+8') {
                # Fill in the gap between CR4 and CR8
                if ($regs[$#regs] ne 'IA_DECODER_REG_CR4') {
                    die("Unexpected gap before CR8");
                }
                $regs[++$#regs] = "";
                $regs[++$#regs] = "";
                $regs[++$#regs] = "";
                $s =~ s/=.*//;
            }
        }

        $regs[++$#regs] = $s;
    }
    elsif ($s =~ /IA_Decoder_Operand_Name/) {
        # Found the correct enumeration.  Emit the array.
        print  "/*\n";
        print  " * Map the Falcon decoder's x86 register names (the enumeration\n";
        print  " * IA_Decoder_Operand_Name) to CPUAPI strings.\n";
        print  " *\n";
        print  " *  NOTE: This file is generated by mapregs.pl reading the\n";
        print  " *        decoder header files automatically.  Do not edit.\n";
        print  " */\n\n";

        print  "#ifndef _DECODER_TO_CPUAPI_REGS_\n";
        print  "#define _DECODER_TO_CPUAPI_REGS_\n\n";

        print  "#include \"cpuapi_arch_ia32.h\"\n\n";

        print  "#ifdef __cplusplus\n";
        print  "extern \"C\"\n";
        print  "{\n";
        print  "#endif\n\n";

        printf "char * const decoderRegsToCPUAPI[%d]\n", $#regs + 1;
        print  "#ifdef INIT_DECODER_TO_CPUAPI_REGS_VALUES\n";
        print  "    = {\n";

        for (my $i = 0; $i <= $#regs; $i++) {
            my $t = translate_reg($regs[$i]);
            $t .= ',' if ($i != $#regs);

            printf "    %-30s /* %-25s */\n", $t, $regs[$i];
        }

        print  "}\n";
        print  "#endif /* INIT_DECODER_TO_CPUAPI_REGS_VALUES */\n";
        print  ";\n\n";

        print  "#ifdef __cplusplus\n";
        print  "}\n";
        print  "#endif\n\n";

        print  "#endif /* _DECODER_TO_CPUAPI_REGS_ */\n";
        exit(0);
    }
}
